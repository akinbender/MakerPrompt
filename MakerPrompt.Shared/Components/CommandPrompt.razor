@using System.Collections.Generic
@inherits ConnectionComponentBase

<div class="bg-body-tertiary rounded p-3 d-flex flex-column h-100">
    <div class="d-flex align-items-center justify-content-between mb-2">
        <div class="d-flex align-items-center gap-2">
            @if (!string.IsNullOrEmpty(_activePrinterName))
            {
                <span class="badge bg-secondary">
                    <i class="bi bi-terminal me-1"></i>@_activePrinterName
                </span>
            }
        </div>
        <div class="form-check form-switch mb-0">
            <input class="form-check-input" type="checkbox" id="toggle-telemetry-echo" @bind="_showTelemetry" />
            <label class="form-check-label ms-2" for="toggle-telemetry-echo">
                @Localizer[Resources.CommandPrompt_ShowTelemetry]
            </label>
        </div>
    </div>

    <div class="overflow-y-auto mb-2 flex-grow-1" @ref="historyContainer">
        @foreach (var entry in GetHistorySnapshot())
        {
            <div class="terminal-line">
                @if (entry.Type == TerminalEntryType.Sent)
                {
                    <span class="text-primary">&gt;&gt;</span>
                    <span class="text-muted">@entry.Timestamp.ToString("HH:mm:ss")</span>
                    <span class="text-white">@entry.Text</span>
                }
                else if (entry.Type == TerminalEntryType.Received)
                {
                    <span class="text-success">&lt;&lt;</span>
                    <span class="text-muted">@entry.Timestamp.ToString("HH:mm:ss")</span>
                    <span class="text-white">@entry.Text</span>
                }
                else
                {
                    <span class="text-warning">@entry.Text</span>
                }
            </div>
        }
    </div>

    <div class="input-group mt-auto">
        <input type="text" class="form-control bg-dark-subtle border-light-subtle"
               placeholder="@Localizer[Resources.CommandPrompt_EnterCommand]" @bind="inputCommand"
               disabled="@(!IsConnected && PrinterServiceFactory.Current?.ConnectionType != Enums.PrinterConnectionType.PrusaLink)"
               @onkeypress="HandleKeyPress" />
        <button class="btn btn-outline-secondary" @onclick="SendCommand"
                disabled="@(!IsConnected && PrinterServiceFactory.Current?.ConnectionType != Enums.PrinterConnectionType.PrusaLink)">
            @Localizer[Resources.CommandPrompt_Send]
        </button>
    </div>
</div>
@code {
    private enum TerminalEntryType { Sent, Received, System }
    private class TerminalEntry
    {
        public string Text { get; set; } = string.Empty;
        public TerminalEntryType Type { get; set; }
        public DateTime Timestamp { get; set; } = DateTime.Now;
    }

    private readonly object _historyLock = new();
    private List<TerminalEntry> history = new();
    private string inputCommand = string.Empty;
    private ElementReference historyContainer;

    // Tracks whether the last telemetry update came from a user-initiated command.
    private bool _expectTelemetryEcho;
    private bool _showTelemetry;

    // Multi-printer: track which printer the terminal is attached to
    private string _activePrinterName = string.Empty;
    private string _lastPrinterConnectionName = string.Empty;

    private async Task SendCommand()
    {
        if (string.IsNullOrWhiteSpace(inputCommand) || PrinterServiceFactory.Current == null) return;

        var command = inputCommand.Trim();
        AddEntryToHistory(new TerminalEntry { Text = command, Type = TerminalEntryType.Sent, Timestamp = DateTime.Now });
        inputCommand = string.Empty;

        // Next telemetry response is likely the echo of this command.
        _expectTelemetryEcho = true;

        try
        {
            await PrinterServiceFactory.Current.WriteDataAsync(command);
            await ScrollToBottom();
        }
        catch (Exception ex)
        {
            AddSystemMessage(string.Format(Localizer[Resources.CommandPrompt_ErrorMessage], ex.Message), true);
        }
    }

    private void HandleKeyPress(KeyboardEventArgs args)
    {
        if (args.Key == "Enter")
        {
            SendCommand().ConfigureAwait(false);
        }
    }

    protected override void HandleTelemetryUpdated(object? sender, PrinterTelemetry printerTelemetry)
    {
        var response = printerTelemetry.LastResponse;
        if (string.IsNullOrWhiteSpace(response))
        {
            return;
        }

        // When telemetry echo display is disabled, only show responses that are
        // likely tied to a user-initiated command.
        if (!_showTelemetry && !_expectTelemetryEcho)
        {
            return;
        }

        _expectTelemetryEcho = false;

        AddEntryToHistory(new TerminalEntry
        {
            Text = response.Trim(),
            Type = TerminalEntryType.Received,
            Timestamp = DateTime.Now
        });
        InvokeAsync(StateHasChanged);
        InvokeAsync(ScrollToBottom);
    }

    protected override void HandleConnectionChanged(object? sender, bool connected)
    {
        base.HandleConnectionChanged(sender, connected);

        var currentName = PrinterServiceFactory.Current?.ConnectionName ?? string.Empty;

        // Detect printer switch — clear history and notify
        if (connected && !string.IsNullOrEmpty(currentName) && currentName != _lastPrinterConnectionName && !string.IsNullOrEmpty(_lastPrinterConnectionName))
        {
            lock (_historyLock)
            {
                history.Clear();
            }
            AddSystemMessage($"Switched to {currentName}");
        }

        _lastPrinterConnectionName = currentName;
        _activePrinterName = connected ? currentName : string.Empty;

        var message = connected ? string.Format(Localizer[Resources.CommandPrompt_ConnectedMessage], currentName)
                        : string.Format(Localizer[Resources.CommandPrompt_DisconnectedMessage], currentName);
        AddSystemMessage(message);
        InvokeAsync(StateHasChanged);
    }

    private void AddSystemMessage(string message, bool isError = false)
    {
        AddEntryToHistory(new TerminalEntry
        {
            Text = message,
            Type = isError ? TerminalEntryType.System : TerminalEntryType.System,
            Timestamp = DateTime.Now
        });
        InvokeAsync(StateHasChanged);
        InvokeAsync(ScrollToBottom);
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JS.ScrollToBottom(historyContainer);
        }
        catch
        {
            // Ignore JS interop errors
        }
    }

    private void AddEntryToHistory(TerminalEntry entry)
    {
        lock (_historyLock)
        {
            history.Add(entry);
            // Limit history size to prevent memory issues
            if (history.Count > 1000)
            {
                history.RemoveAt(0);
            }
        }
    }

    private List<TerminalEntry> GetHistorySnapshot()
    {
        lock (_historyLock)
        {
            return new List<TerminalEntry>(history);
        }
    }
}